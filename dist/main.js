/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/js/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/js/components/AI_Bot.js":
/*!*************************************!*\
  !*** ./src/js/components/AI_Bot.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return AI_Bot; });\n/* harmony import */ var _Ball__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Ball */ \"./src/js/components/Ball.js\");\n\n/*\n*\n* AI opponent\n* This class abstracts all AI operations\n*\n*/\n\nclass AI_Bot {\n\n    /**\n     * \n     * @param {Game} game - Main game object\n     * @param {Ball} ball - The ball in play\n     * @param {Paddle} paddle - Paddle that the bot controls\n     * @param {number} difficulty - Decides how \"intelligent\" the bot is\n     */\n    constructor(game, ball, paddle, difficulty=1.2) {\n        this.game = game;\n        this.ball = ball; \n        this.paddle = paddle;\n        this.difficulty = difficulty;\n        let shadowBall = new _Ball__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.ball.x, this.ball.y, this.ball.radius, this.ball.speedX * this.difficulty, this.ball.speedY * this.difficulty, 'transparent', this.game.canvasCtx);\n        shadowBall.setBaseSpeed(game.config.speed.base_speed);\n        this.game.objects['ball_shadow'] = shadowBall;\n    }\n\n    /**\n     * \n     * Dynamically predict the path where the paddle must move,\n     * we care only about the y co-ordinate. However, x can be\n     * used to introduce some error in the prediction.\n     *   \n     */\n    predictPath() {\n        const sb = this.game.objects['ball_shadow'];\n        const max_w = this.game.config.dimensions.board.width;\n        const board_centre = max_w / 2;\n\n        /**\n         * Use shadow ball location only if the ball is moving towards the paddle.\n         * Otherwise, just let the paddle stay where it is.\n         */\n        if(this.paddle.x > board_centre) {\n            if(this.ball.speedX > 0)\n                return {x: sb.x, y: sb.y};\n        }\n        else if (this.paddle.x < board_centre) {\n            if(this.ball.speedX < 0)\n                return {x: sb.x, y: sb.y};\n        }\n        // don't move\n        return false;\n    }\n\n    setDifficulty(dfactor) {\n        this.difficulty = dfactor;\n        this.reset();\n    }\n\n\n    /**\n     * \n     * Reset position and speed of shadow ball according to actual ball.\n     */\n    reset() {\n        this.game.objects['ball_shadow'].setLoc(this.ball.x, this.ball.y);\n        this.game.objects['ball_shadow'].setSpeed(this.ball.speedX * this.difficulty, this.ball.speedY * this.difficulty);\n    }\n\n    /**\n     * \n     * @param {Object} paddleControls - Interface to move the paddle\n     * Controls movement of the paddle according to the predicted path of the ball.\n     * \n     */\n    control(paddleControls) {\n        if(this.game.paused)\n            return;\n\n        let dir = \"down\"; \n        let nextPt = this.predictPath();\n\n        if(!nextPt) {\n            paddleControls[dir](this.paddle, \"stop\"); \n            return;\n        }\n        \n        if(nextPt.y < this.paddle.y + this.paddle.height/2)\n            dir = \"up\";\n\n        if(nextPt.y >= this.paddle.y + this.paddle.height/4 && nextPt.y <= this.paddle.y + this.paddle.height) {\n            paddleControls[dir](this.paddle, \"stop\"); // stop moving if the point is exactly in the middle\n        }\n        else\n            paddleControls[dir](this.paddle, \"move\"); // move up/down\n    }\n\n}\n\n//# sourceURL=webpack:///./src/js/components/AI_Bot.js?");

/***/ }),

/***/ "./src/js/components/Ball.js":
/*!***********************************!*\
  !*** ./src/js/components/Ball.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Ball; });\n/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component */ \"./src/js/components/Component.js\");\n/* harmony import */ var _game_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../game/utils */ \"./src/js/game/utils.js\");\n\n\n\n\nclass Ball extends _Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n\n    /**\n     * \n     * @param {number} x co-ordinate\n     * @param {number} y co-ordinate\n     * @param {number} radius of ball\n     * @param {number} speedX - x component of velocity\n     * @param {number} speedY - y component of velocity\n     * @param {string} color - hex code or named color value\n     * @param {CanvasRenderingContext2D} ctx \n     */\n    constructor(x, y, radius, speedX, speedY, color, ctx) {\n        super(x,y,speedX,speedY,color,ctx);\n        this.radius = radius;\n    }\n\n    render() {\n        const renderer = function(ctx, x, y) {\n            ctx.beginPath();\n            ctx.arc(x, y, this.radius, 0, 2 * Math.PI);\n        }.bind(this);\n\n        super.render(renderer); \n    }\n\n    /**\n     * \n     * @param {number} delay - Time delay for reset\n     * Resets ball position back to the centre of the board, \n     * randomly generates speed in the range [3,8] \n     * \n     */\n    reset(delay=1000, change_speed=true, speed_range=[2,12]) {\n\n        this.setLoc(this.canvasCtx.canvas.width/2, this.canvasCtx.canvas.height/2);\n        this.setSpeed(0,0);\n\n        let [spMin, spMax] = speed_range;\n        let resetFunc = function(spMin, spMax) {\n            const dirX = Object(_game_utils__WEBPACK_IMPORTED_MODULE_1__[\"randomDir\"])();\n            const dirY = Object(_game_utils__WEBPACK_IMPORTED_MODULE_1__[\"randomDir\"])();\n\n            let speeds = {\n                x: dirX * this.speedX,\n                y: dirY * this.speedY\n            };\n\n            if(change_speed) {\n                speeds = {\n                    x: dirX * Object(_game_utils__WEBPACK_IMPORTED_MODULE_1__[\"randomFloat\"])(spMin, spMax),\n                    y: dirY * Object(_game_utils__WEBPACK_IMPORTED_MODULE_1__[\"randomFloat\"])(spMin, spMax)\n                };\n            }\n            \n            //console.log(speeds);\n            this.setSpeed(speeds.x, speeds.y);\n        }.bind(this);\n\n        // reset after 1 second\n        setTimeout(() => resetFunc(spMin, spMax), delay);\n    }\n\n    collision(paddle, minSpeed = 6, boost=false) {\n        let cf = paddle.cfactor;\n\n        // boost bounce\n        if(boost)\n            cf = 1 + cf;\n\n        // if(boost)\n        //     console.log(`BOOOST >>>>> ${cf}`)\n\n        let new_vx = -this.speedX * cf;\n\n        // don't let speed drop too low\n        if(Math.abs(new_vx) <= 3) {\n            const vmod = Math.abs(new_vx) + minSpeed;\n            new_vx = (new_vx > 0)?(vmod):(-vmod);\n        }\n        //const old_ang = this.getVelocityAngle(-this.speedX, this.speedY);\n        this.speedX = new_vx; \n        if(this.speedX > 0) {\n            this.x = 1.5 * paddle.width;\n        }\n            \n        else {\n            this.x = this.canvasCtx.canvas.width - 1.5 * paddle.width;\n        }            \n        //const new_ang = this.getVelocityAngle(new_vx, this.speedY);\n    }\n\n    /**\n     * \n     * @param {number} vx \n     * @param {number} vy\n     * Returns collision angle, added as a test function to compare elastic and inelastic\n     * collision difference.\n     */\n    getVelocityAngle(vx = this.speedX, vy = this.speedY) {\n        const ang = Math.atan(vy / vx);\n        return (180/Math.PI) * ang;\n    }\n}\n\n//# sourceURL=webpack:///./src/js/components/Ball.js?");

/***/ }),

/***/ "./src/js/components/Component.js":
/*!****************************************!*\
  !*** ./src/js/components/Component.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Component; });\n/* harmony import */ var _game_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game/utils */ \"./src/js/game/utils.js\");\n/* \n*    Represents a game component\n*/\n\n\nclass Component {\n\n    /**\n     * \n     * @param {number} x co-ordinate\n     * @param {number} y co-ordinate\n     * @param {number} speedX - x component of velocity\n     * @param {number} speedY - y component of velocity\n     * @param {string} color - hex code or named color value\n     * @param {CanvasRenderingContext2D} ctx \n     */\n    constructor(x, y, speedX, speedY, color, ctx) {\n        this.x = x;\n        this.y = y; \n        this.speedX = speedX;\n        this.speedY = speedY;\n        this.color = color; \n        this.canvasCtx = ctx;\n        this.base_speed = 1;\n    }\n\n    /**\n     * \n     * @param {number} newX New x co-ordinate\n     * @param {number} newY New y co-ordinate\n     * Checks if the new position is within bounds\n     * We assume the game area occupies all of the canvas.\n     */\n    checkBounds(newX, newY) {\n        let max_h = this.canvasCtx.canvas.height; \n        let max_w = this.canvasCtx.canvas.width;\n        let status = false; \n        if ((newX <= max_w && newX >= 0) && (newY <= max_h && newY >= 0))  \n            status = true; \n        \n        return status;\n    }\n\n    /**\n     * \n     * @param {number} vx Horizontal velocity component\n     * @param {number} vy Vertical velocity component\n     * Sets speeds (with direction) for the component\n     * \n     */\n    setSpeed(vx, vy) {\n        this.speedX = vx; \n        this.speedY = vy; \n    }   \n\n    /**\n     * \n     * @param {number} k \n     */\n    boostSpeed(k, base=true) {\n        if(base) {\n            this.setSpeed(Object(_game_utils__WEBPACK_IMPORTED_MODULE_0__[\"getSign\"])(this.speedX) * this.base_speed * k, k * Object(_game_utils__WEBPACK_IMPORTED_MODULE_0__[\"getSign\"])(this.speedY) * this.base_speed);\n        }\n        else\n            this.setSpeed(k * this.speedX, k * this.speedY);\n    }\n\n    setBaseSpeed(bspeed) {\n        this.base_speed = bspeed; \n    }\n\n\n    /**\n     * \n     * Flips speed direction\n     */\n    reverseX() {\n        this.speedX = -this.speedX;\n    }\n\n    reverseY() {\n        this.speedY = -this.speedY; \n    }\n\n    /**\n     * \n     * @param {number} x x co-ordinate\n     * @param {number} y y co-ordinate\n     * Sets location of the component in 2D space\n     */\n    setLoc(x, y) {\n        if(!this.checkBounds(x,y)) {\n            //debug console.log(\"Component out of bounds: \", this);\n            return false;\n        }\n        this.x = x; \n        this.y = y;\n        return true;\n    }\n\n    /**\n     * Moves the component according to it's current speed in the current frame\n     */\n    move() {\n        let newLoc = {\n            x: this.x + this.speedX,\n            y: this.y + this.speedY\n        }\n\n        const w = this.canvasCtx.canvas.width;\n        const h = this.canvasCtx.canvas.height;\n        const delta = 3; // 3px error\n\n        if(this.checkBounds(newLoc.x, newLoc.y)) {\n            this.x = newLoc.x;\n            this.y = newLoc.y;\n            return true;\n        }\n        else {\n            // calculate new bounds\n            if(newLoc.x >= w)\n                this.x = w - delta;\n            if(newLoc.x <= 0)\n                this.x = delta;\n            if(newLoc.y >= h)\n                this.y = h - delta;\n            if(newLoc.y <= 0)\n                this.y = delta;\n            return true;\n        }\n        //console.log(\"Component out of bounds: \", this);\n        return false;\n    }\n\n    /**\n     * \n     * @param {function} renderer - The callback function to render the component\n     */\n    render(renderer) {\n        this.canvasCtx.fillStyle = this.color;\n        renderer(this.canvasCtx, this.x, this.y);\n        this.canvasCtx.fill();\n    }\n}\n\n\n//# sourceURL=webpack:///./src/js/components/Component.js?");

/***/ }),

/***/ "./src/js/components/Paddle.js":
/*!*************************************!*\
  !*** ./src/js/components/Paddle.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Paddle; });\n/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component */ \"./src/js/components/Component.js\");\n/* harmony import */ var _game_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../game/utils */ \"./src/js/game/utils.js\");\n\n\n\nclass Paddle extends _Component__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n\n    /**\n     * \n     * @param {number} x co-ordinate\n     * @param {number} y co-ordinate\n     * @param {number} width Paddle width\n     * @param {number} height Paddle height\n     * @param {number} speed Paddle speed\n     * @param {string} color - hex code or named color value\n     * @param {CanvasRenderingContext2D} ctx \n     * @param {number} cfactor - Collision factor\n     */\n    constructor(x, y, width, height, speed, color, ctx, cfactor = Object(_game_utils__WEBPACK_IMPORTED_MODULE_1__[\"randomFloat\"])(0.6, 0.95)) {\n        super(x,y,0,speed,color,ctx);\n        this.width = width;\n        this.height = height;\n        this.cfactor = cfactor;\n        this.setSpeed(0,0);\n        this.curSpeed = Math.abs(speed); \n    }\n\n    render() {\n        const renderer = function(ctx, x, y) {\n            ctx.rect(x,y, this.width, this.height);\n        }.bind(this);\n        // bind current object to renderer\n        super.render(renderer);\n    }\n\n    halt() {\n        this.setSpeed(0, 0);\n    }\n\n    moveUp() {\n        this.setSpeed(0, -this.curSpeed);\n    }\n\n    moveDown() {\n        this.setSpeed(0, this.curSpeed);\n    }\n\n    boostSpeed(k) {\n        super.boostSpeed(k);\n        this.curSpeed = this.base_speed * k;\n    }\n\n\n    /**\n     * Resets paddle speed and position\n     */\n    reset() {\n        this.setSpeed(0,0);\n        this.y = (this.canvasCtx.canvas.height - this.height)/2;\n    }\n}\n\n//# sourceURL=webpack:///./src/js/components/Paddle.js?");

/***/ }),

/***/ "./src/js/game/Game.js":
/*!*****************************!*\
  !*** ./src/js/game/Game.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Game; });\n/* harmony import */ var _components_Ball__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/Ball */ \"./src/js/components/Ball.js\");\n/* harmony import */ var _components_Paddle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/Paddle */ \"./src/js/components/Paddle.js\");\n/* harmony import */ var _Player__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Player */ \"./src/js/game/Player.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ \"./src/js/game/utils.js\");\n\n\n\n\n\nclass Game {\n\n    /**\n     * @param {string} name - The name of the game \n     * @param {CanvasRenderingContext2D} ctx - Canvas Context object for rendering\n     * @param {Object} objects - Game components to be drawn\n     * @param {Object} config - Game configurations\n     */\n    constructor(name, ctx, config) {\n        this.name = name;\n        this.canvasCtx = ctx;\n        this.config = config;\n        this.base_speed = config.speed.base_speed;\n        this.minFactor = config.speed.min_factor;\n        this.maxFactor = config.speed.max_factor; // keep the last few points to customize\n        this.speedStep = config.speed.step;\n        this.objects = this.generateObjectsFromConfig();\n        this.paused = false;\n        this.max_counter = config.score_counter;\n        this.counter = 0; // no. of turns for which score is unchanged\n        this.score = [0, 0];\n        this.type = config.game_type_keys[\"AI mode\"];\n        this.player = new _Player__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this, 2, config.game_type[this.type], [config.keys.p0, config.keys.p1]);\n    }\n\n    /**\n    * Generates game objects, TODO: this should go into Game\n    */\n    generateObjectsFromConfig() {\n        const CONFIGS = this.config;\n        const pDim = CONFIGS.dimensions.paddle;\n        const boardDim = CONFIGS.dimensions.board;\n        const ballDim = CONFIGS.dimensions.ball;\n        const colors = CONFIGS.colors;\n        let ballLoc = CONFIGS.locs.ball;\n        let locs = CONFIGS.locs;\n\n        const baseSpeed = this.base_speed;\n        const [minF, maxF] = [this.minFactor, this.maxFactor]\n\n        const ballSpeed = {\n            //x: baseSpeed * randomInt(minF, maxF) * randomDir(),\n            //y: baseSpeed * randomInt(minF, maxF) * randomDir()\n            x: baseSpeed * 2,\n            y: baseSpeed * 2\n        };\n\n        // set ball and paddle locations dynamically\n        ballLoc.x = boardDim.width/2;\n        ballLoc.y = boardDim.height/2;\n        locs.p0.x = 0 + pDim.width;\n        locs.p0.y = ballLoc.y;\n        locs.p1.x = boardDim.width - pDim.width;\n        locs.p1.y = locs.p0.y;\n\n        const pSpeed = CONFIGS.speed['paddle-max']; \n        let b = new _components_Ball__WEBPACK_IMPORTED_MODULE_0__[\"default\"](ballLoc.x, ballLoc.y, ballDim.radius, ballSpeed.x, ballSpeed.y, colors.ball, this.canvasCtx);\n        b.setBaseSpeed(baseSpeed);\n        let p0 = new _components_Paddle__WEBPACK_IMPORTED_MODULE_1__[\"default\"](locs.p0.x, locs.p0.y, pDim.width, pDim.height, pSpeed, colors.paddle, this.canvasCtx);\n        let p1 = new _components_Paddle__WEBPACK_IMPORTED_MODULE_1__[\"default\"](locs.p1.x, locs.p1.y, pDim.width, pDim.height, pSpeed, colors.paddle, this.canvasCtx);\n        return {\n            'ball': b,\n            'paddle-0': p0,\n            'paddle-1': p1\n        };\n    }\n\n    debug() {\n        // to see shadow ball in action\n        //this.objects['ball_shadow'].color = 'cyan';\n        console.log(this.canvasCtx.canvas.height, this.canvasCtx.canvas.width);\n    }\n    /**\n     * Updates all objects\n     */\n    update() {\n        this.debug();\n        Object.keys(this.objects).forEach((k) => {\n            let curObj = this.objects[k];\n            curObj.move();\n        });\n    }\n\n    /** \n     * Changes game mode to 1P, 2P, AI \n    */\n    changeMode(game_type) {\n        this.type = game_type;\n        this.player = new _Player__WEBPACK_IMPORTED_MODULE_2__[\"default\"](this, 2, this.config.game_type[game_type], [this.config.keys.p0, this.config.keys.p1]);\n        setTimeout(() => { this.player.resetNPC() }, 1000);\n    }\n\n    /**\n     * Clears board for re-drawing\n     */\n    clearBoard() {\n        const ctx = this.canvasCtx;\n        const canvas = this.canvasCtx.canvas;\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        ctx.fillStyle = \"#1b1b1c\";\n        ctx.fillRect(0, 0, canvas.width, canvas.height);\n\n        // draw dottted line\n        ctx.beginPath();\n        ctx.strokeStyle = \"white\";\n        ctx.lineWidth = 3;\n        ctx.setLineDash([5,10]);\n        ctx.moveTo(canvas.width / 2, 0);\n        ctx.lineTo(canvas.width / 2, canvas.height);\n        ctx.stroke();\n        //ctx.fillRect(canvas.width / 2, 0, 1, canvas.height);\n    }\n\n    /**\n     * Renders all game objects\n     */\n    render() {\n        this.clearBoard();\n\n        const ctx = this.canvasCtx;\n        const canvas = this.canvasCtx.canvas;\n        // render scores\n        ctx.font = this.config.font;\n        //ctx.fillStyle = this.config.colors.score;\n        ctx.fillStyle = \"white\";\n        ctx.fillText(`${this.score[0]}`, (1 / 4) * canvas.width, 40);\n        ctx.fillText(`${this.score[1]}`, (3 / 4) * canvas.width, 40);\n\n        Object.keys(this.objects).forEach((k) => {\n            if(k != 'ball_shadow') {\n                let curObj = this.objects[k];\n                curObj.render();\n            }\n        });\n    }\n\n    /**\n     * Updates score depending on direction of the ball\n     */\n    updateScore() {\n        const ball = this.objects['ball']\n        let pid = (ball.speedX > 0) ? 0 : 1; // ball is moving towards left\n        this.score[pid] += 1;\n        console.log(this.score);\n    }\n\n    /**\n     * Checks for collisions and peforms the necessary adjustments\n     */\n    detectCollisions() {\n        const ball = this.objects['ball'];\n        const p0 = this.objects['paddle-0'];\n        const p1 = this.objects['paddle-1'];\n\n        const xlimit = this.canvasCtx.canvas.width;\n        const ylimit = this.canvasCtx.canvas.height;\n\n        let check_ball_collisions = function (ball, p0, p1, xlimit, ylimit, isShadow = false) {\n            if (!isShadow) {\n                const boost = (this.counter) >= (this.max_counter*2);\n\n                // add a small error to smooth out animations\n                if((ball.x - ball.radius <= p0.width) && (ball.y >= (p0.y - ball.radius) && ball.y <= (p0.y + p0.height + ball.radius))) {\n                    // left paddle\n                    Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"playSound\"])(this.config.audio.bounce);\n                    //console.log(this.counter, this.max_counter*2, boost);\n                    ball.collision(p0, 6, boost);\n                    this.counter = (boost)?(1):(this.counter + 1);\n                    // reset must be done on opposite paddle \n                    // so that the shadow ball is calibrated according to it's difficulty setting\n                    this.player.resetNPCByID(1,0);\n                }\n                else if((ball.x + ball.radius >= xlimit-p1.width) && (ball.y > (p1.y - ball.radius) && ball.y < p1.y + (p1.height+ball.radius))) {\n                    Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"playSound\"])(this.config.audio.bounce);\n                    //console.log(this.counter, this.max_counter*2, boost);\n                    ball.collision(p1, 6, boost);\n                    this.counter = (boost)?(1):(this.counter + 1);\n                    this.player.resetNPCByID(0,0);\n                }\n                else if((ball.x + ball.radius >= xlimit) || (ball.x - ball.radius <= 0)) {\n                        // play sound\n                        Object(_utils__WEBPACK_IMPORTED_MODULE_3__[\"playSound\"])(this.config.audio.fail);\n                        // update score\n                        this.updateScore();\n                        // reset ball and npc\n                        ball.reset(1000);\n                        this.player.resetNPC(1000);\n                }\n            }\n\n            // ball and vertical bounds\n            if((ball.y + ball.radius >= ylimit)) {\n                ball.setLoc(ball.x, ylimit - 1.5 * ball.radius);\n                ball.reverseY();\n            }\n            else if((ball.y - ball.radius <= 0)) {\n                ball.setLoc(ball.x, 0+ 1.5*ball.radius);\n                ball.reverseY();\n            }\n        }.bind(this);\n\n        check_ball_collisions(ball, p0, p1, xlimit, ylimit);\n\n        if (this.player.isNPCPresent())\n            check_ball_collisions(this.objects['ball_shadow'], p0, p1, xlimit, ylimit, true);\n\n\n        /* \n         * Ideally this should be in the Paddle class\n         * as it checks if the paddle is within bounds considering paddle height.\n         * The base class only checks if the point is within bounds.\n         */\n        if (p0.y + p0.height >= ylimit) {\n            p0.setLoc(0, ylimit - p0.height);\n        }\n        if (p0.y <= 0) {\n            p0.setLoc(0, 0);\n        }\n\n        if (p1.y + p1.height >= ylimit) {\n            p1.setLoc(xlimit - p1.width, ylimit - p1.height);\n        }\n\n        if (p1.y <= 0) {\n            p1.setLoc(xlimit - p1.width, 0);\n        }\n    }\n\n    /**\n     * Game loop\n     */\n    loop() {\n        if (!this.paused) {\n            this.detectCollisions();\n            // if npc exists, perform npc movements\n            this.player.types.forEach((v, idx) => {\n                if (!v) {\n                    let controls = this.player.getNPCControls();\n                    this.player.npc[idx].control(controls);\n                }\n            });\n            this.update();\n            this.render();\n        }\n        requestAnimationFrame(this.loop.bind(this));\n    }\n\n    /**\n     * Initializes keys\n     */\n    init() {\n        const KEY_SPACE = this.config.keys.general.space; // temp \n        document.addEventListener('keydown', (event) => {\n            if (event.keyCode == KEY_SPACE) {\n                // check if the game has been started first\n                if(!this.paused) \n                    this.pause();\n                else \n                    this.resume();\n\n            }\n        });\n    }\n\n    /**\n     * Starts the game\n     */\n    start() {\n        this.init();\n        requestAnimationFrame(this.loop.bind(this));\n    }\n\n    /**\n     * @param {string} game_type Type of game: {P1,P2,AI}\n     * Restarts game with a new game type\n     */\n    restart(game_type = \"AI\") {\n        this.score = [0, 0];\n        this.objects.ball.reset();\n        this.objects['paddle-0'].reset();\n        this.objects['paddle-1'].reset();\n        this.changeMode(game_type);\n    }\n\n    pause() {\n        const menuElem = document.querySelector('.menu-box');\n        if (!this.paused) {\n            menuElem.style.zIndex = '500';\n            menuElem.style.opacity = '1';\n        }\n        this.paused = true;\n    }\n\n    resume() {\n        const menuElem = document.querySelector('.menu-box');\n        if (this.paused) {\n            menuElem.style.zIndex = '-10';\n            menuElem.style.opacity = '0';\n        }\n        this.paused = false;\n    }\n\n    /**\n     * Resets everything\n     */\n    reset(delay,reset_speed=true, reset_score=true) {\n        this.objects['ball'].reset(delay, reset_speed);\n        this.player.resetNPC(delay);\n        this.objects['paddle-0'].reset();\n        this.objects['paddle-1'].reset();\n\n        if(reset_score) {\n            this.score = [0,0];\n        }\n    }\n\n}\n\n//# sourceURL=webpack:///./src/js/game/Game.js?");

/***/ }),

/***/ "./src/js/game/Player.js":
/*!*******************************!*\
  !*** ./src/js/game/Player.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Player; });\n/* harmony import */ var _components_AI_Bot__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/AI_Bot */ \"./src/js/components/AI_Bot.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./src/js/game/utils.js\");\n\n\n\nclass Player {\n    /**\n     * \n     * @param {number} num_players Total Number of players\n     * @param {Array} player_types Boolean array to indiciate whether the player is human(true) or npc(false)\n     * @param {Array} key_bindings: key codes for players\n     */\n    constructor(game, num_players, player_types, key_bindings) {\n        this.n = num_players;\n        this.types = player_types;\n        this.game = game;\n        this.npc = [null, null];\n        this.key_bindings = key_bindings;\n        this.paddle_controls = {\n            \"up\": function(p, key) {\n                // set upward speed for paddle while button is pressed\n                if(key === 'keyup' || key == 'stop')\n                    p.halt();\n                else if(key == 'keydown' || key == 'move')\n                    p.moveUp();\n            }, \n            \"down\": function(p, key) {\n                if(key === 'keyup' || key == 'stop')\n                    p.halt();\n                else if(key == 'keydown' || key == 'move')\n                    p.moveDown();\n            }\n        }\n\n        this.types.forEach((v, idx) => {\n            if(v) // human\n                this.initControls(idx);\n            else\n                this.initNPC(idx);\n        });\n\n    }\n\n    initControls(pid) {\n        const evts = ['keydown', 'keyup'];\n        evts.forEach((eType) => {\n            const listener = function(event) {\n                const fup = this.paddle_controls.up.bind(this);\n                const fdown = this.paddle_controls.down.bind(this);\n                if(event.keyCode == this.key_bindings[pid]['up'])\n                    fup(this.game.objects[`paddle-${pid}`], event.type);\n                if(event.keyCode == this.key_bindings[pid]['down'])\n                    fdown(this.game.objects[`paddle-${pid}`], event.type);\n            }.bind(this);\n\n            document.addEventListener(eType,listener);\n        });\n    }\n\n    initNPC(pid) {\n        const diffFactor = this.game.config.ai_factor; \n        let curNPC = new _components_AI_Bot__WEBPACK_IMPORTED_MODULE_0__[\"default\"](this.game, this.game.objects.ball, this.game.objects[`paddle-${pid}`], diffFactor);\n        this.npc[pid] = curNPC;\n    }\n\n    getNPCControls() {\n        let controls = {\n            \"up\": this.paddle_controls.up.bind(this),\n            \"down\": this.paddle_controls.down.bind(this)\n        };\n        return controls;\n    }\n\n    resetNPC(delay=1000) {\n        let resetFunc = function() {\n            this.types.forEach((v,idx) => {\n                if(!v)\n                    this.npc[idx].reset();\n            });\n        }.bind(this);\n        setTimeout(() => resetFunc(), delay);\n    }\n\n    /**\n     * \n     * @param {integer} NPC id\n     * @param {number} delay Delay in milliseconds\n     * Reset only the specified NPC.\n     * This makes sure the shadow ball is calibrated with this NPC's speed.\n     * \n     */\n    resetNPCByID(id, delay=1000) {\n        let resetFunc = function(idx) {\n            this.npc[idx].reset();\n        }.bind(this);\n        setTimeout(() => resetFunc(id), delay);\n    }\n\n    /**\n     * \n     * Sets NPC difficulty factor\n     */\n    setDifficultyFactorByID(id, val) {\n        if(this.npc[id])\n            this.npc[id].setDifficulty(val);\n    }\n \n    isNPCPresent() {\n        return this.npc[0] || this.npc[1];\n    }\n}\n\n//# sourceURL=webpack:///./src/js/game/Player.js?");

/***/ }),

/***/ "./src/js/game/listeners.js":
/*!**********************************!*\
  !*** ./src/js/game/listeners.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return setupUI; });\n/**\n * User Interface related events\n */\nfunction setupUI(game, ctx) {\n    // start button\n    document.querySelector('.btn-start').addEventListener('click', (e) => {\n        e.target.style.zIndex = '-100';\n        e.target.style.opacity = '0';\n        //ctx.canvas.style.border = '1px solid lightgrey';\n        game.start();\n    });\n\n    // restart button\n    document.querySelector('#icon-restart').addEventListener('click', e => game.restart(game.type));\n\n    // set game type \n    const curGameClass = `#btn-${game.type}`\n    document.querySelector(curGameClass).classList.add('configs__option-selected');\n\n    const gTypes = ['1P','2P', 'AI'];\n    gTypes.forEach((typ) => {\n        document.querySelector(`#btn-${typ}`).addEventListener('click', (e) => {\n            // first toggle all other classes off\n            gTypes.forEach((v) => {\n                const className = `#btn-${v}`;\n                document.querySelector(className).classList.remove('configs__option-selected');\n            });\n\n            e.target.classList.add('configs__option-selected');\n            game.restart(typ);\n            // resume game after restarting\n            setTimeout(() => game.resume(), 300);\n        });\n    });\n\n    // tune difficulty factor\n    const npc_ids = [0, 1];\n    for(var i in npc_ids) {\n        var pid = parseInt(i)+1;\n        document.querySelector(`#p${pid}-df`).addEventListener('change', (e) => {\n            const elem = e.target; \n            const diffVal = parseFloat(elem.value);\n            console.log(diffVal);\n            game.player.setDifficultyFactorByID(i,diffVal);\n            game.reset();\n        });\n    }\n\n    // tune speeds\n    const speed_ids = ['ball-speed', 'paddle-speed'];\n    for(var i in speed_ids) {\n        document.querySelector(`#${speed_ids[i]}`).addEventListener('change', (e) => {\n            const elem = e.target; \n            const diffVal = parseFloat(elem.value);\n            if(elem.id === 'ball-speed') {\n                game.objects['ball'].boostSpeed(diffVal, true);\n                const b = game.objects['ball'];\n                //console.log(b.speedX, b.speedY);\n            }\n            if(elem.id === 'paddle-speed') {\n                game.objects['paddle-0'].boostSpeed(diffVal, true);\n                game.objects['paddle-1'].boostSpeed(diffVal, true);\n            }\n            game.reset(1000,true,false);\n        });\n    }\n\n    setDefaults(game);\n}\n\nfunction setDefaults(game) {\n    const input_elems = ['#p1-df', '#p2-df', '#ball-speed', '#paddle-speed'].map((v) => document.querySelector(v));\n    const defaults = [\n        game.config['ai_factor'],\n        game.config['ai_factor'],\n        Math.abs(game.config.speed.ball.x),\n        game.config.speed['paddle-max']\n    ]; \n\n    input_elems.forEach((elem, idx) => {\n        elem.setAttribute(\"value\", defaults[idx]);\n    });\n}\n\n//# sourceURL=webpack:///./src/js/game/listeners.js?");

/***/ }),

/***/ "./src/js/game/pong-conf.json":
/*!************************************!*\
  !*** ./src/js/game/pong-conf.json ***!
  \************************************/
/*! exports provided: font, score_counter, ai_factor, game_type_keys, game_type, keys, colors, dimensions, speed, locs, audio, default */
/***/ (function(module) {

eval("module.exports = {\"font\":\"35px Montserrat\",\"score_counter\":5,\"ai_factor\":1.2,\"game_type_keys\":{\"1 player\":\"1P\",\"2 player\":\"2P\",\"AI mode\":\"AI\"},\"game_type\":{\"1P\":[true,false],\"1P1\":[true,false],\"1P2\":[false,true],\"2P\":[true,true],\"AI\":[false,false]},\"keys\":{\"p0\":{\"up\":87,\"down\":83},\"p1\":{\"up\":38,\"down\":40},\"general\":{\"space\":32}},\"colors\":{\"bg-primary\":\"black\",\"bg-secondary\":\"lightgrey\",\"ball\":\"white\",\"paddle\":\"white\",\"score\":\"gold\"},\"dimensions\":{\"board\":{\"height\":480,\"width\":800},\"paddle\":{\"height\":70,\"width\":10},\"ball\":{\"radius\":7}},\"speed\":{\"base_speed\":2,\"min_factor\":1,\"max_factor\":15,\"step\":0.5,\"ball\":{\"x\":-10,\"y\":10},\"p0\":{\"x\":0,\"y\":0,\"max\":5},\"p1\":{\"x\":0,\"y\":0,\"max\":5},\"paddle-max\":8},\"locs\":{\"ball\":{\"x\":400,\"y\":240},\"p0\":{\"x\":0,\"y\":30},\"p1\":{\"x\":790,\"y\":100}},\"audio\":{\"bounce\":\"./sounds/bounce.wav\",\"fail\":\"./sounds/fail.wav\"}};\n\n//# sourceURL=webpack:///./src/js/game/pong-conf.json?");

/***/ }),

/***/ "./src/js/game/utils.js":
/*!******************************!*\
  !*** ./src/js/game/utils.js ***!
  \******************************/
/*! exports provided: playSound, randomInt, randomFloat, random, randomDir, getSign */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"playSound\", function() { return playSound; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"randomInt\", function() { return randomInt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"randomFloat\", function() { return randomFloat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"random\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"randomDir\", function() { return randomDir; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSign\", function() { return getSign; });\n/**\n * \n * @param {string} path - Path to sound file\n * This function requires some kind of user interaction to happen prior to calling it\n */\n\nvar audio_lock = false;\n\nfunction playSound(path) {\n    if(!audio_lock) {\n        audio_lock = true;\n        const aud = new Audio(path);\n        aud.play();\n        setTimeout(() => { audio_lock = false }, 500);\n    }   \n}\n\nfunction randomInt(a, b) {\n    return Math.floor(Math.random() * (b-a)) + a;\n}\n\nfunction randomFloat(a, b) {\n    return Math.random() * (b-a) + a;\n}\n\nfunction random(numList) {\n    const idx = randomInt(0, numList.length);\n    return numList[idx];\n}\n\nfunction randomDir() {\n    return random([-1,1]);\n}\n\nfunction getSign(val) {\n    return (val / Math.abs(val));\n}\n\n//# sourceURL=webpack:///./src/js/game/utils.js?");

/***/ }),

/***/ "./src/js/index.js":
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _components_Ball__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/Ball */ \"./src/js/components/Ball.js\");\n/* harmony import */ var _components_Paddle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/Paddle */ \"./src/js/components/Paddle.js\");\n/* harmony import */ var _game_Game__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./game/Game */ \"./src/js/game/Game.js\");\n/* harmony import */ var _game_listeners__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./game/listeners */ \"./src/js/game/listeners.js\");\n/* harmony import */ var _game_Player__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./game/Player */ \"./src/js/game/Player.js\");\n\n\n\n\n\n\n\nlet GAME_CONFIG = __webpack_require__(/*! ./game/pong-conf.json */ \"./src/js/game/pong-conf.json\")\n\n\nconst breakpoints = {\n    large: 1024,\n    medium: 864,\n    msmall: 768,\n    small: 560\n};\n\n/**\n * Adapts to device screen size\n */\nfunction adaptCanvas(canvas) {\n    const canvas_sizes = {\n        large: [480, 800],\n        medium: [480, 640],\n        msmall: [480, window.innerWidth-16],\n        small: [320, window.innerWidth-16]\n    };\n\n    const w = window.innerWidth;\n    const h = window.innerHeight;\n\n    canvas.width = GAME_CONFIG.dimensions.board.width;\n    canvas.height = GAME_CONFIG.dimensions.board.height;\n\n    if(w < breakpoints.medium) {\n        canvas.height = canvas_sizes.medium[0];\n        canvas.width = canvas_sizes.medium[1];\n    }\n\n    if(w < breakpoints.msmall) {\n        canvas.height = canvas_sizes.msmall[0];\n        canvas.width = canvas_sizes.msmall[1];\n    }\n\n    if(w < breakpoints.small) {\n        canvas.height = canvas_sizes.small[0];\n        canvas.width = canvas_sizes.small[1];\n    }\n    return canvas;\n}\n\n\n/**\n * Initializes canvas\n */\nfunction getCanvasContext() {\n    var canvas = document.querySelector('#canvas');\n    canvas = adaptCanvas(canvas);\n    // alter configs if needed\n    GAME_CONFIG.dimensions.board.width = canvas.width;\n    GAME_CONFIG.dimensions.board.height = canvas.height;\n    console.log(canvas.width, canvas.height);\n    let ctx = canvas.getContext('2d');\n    return ctx;\n}\n\n\nlet ctx = getCanvasContext();\nlet game = new _game_Game__WEBPACK_IMPORTED_MODULE_2__[\"default\"]('ai-pong', ctx, GAME_CONFIG);\nwindow.gameObj = game; // testing\nObject(_game_listeners__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(game, ctx);\n\n// this is done when the start button is clicked, so not needed\n//game.start();\n\n//# sourceURL=webpack:///./src/js/index.js?");

/***/ })

/******/ });